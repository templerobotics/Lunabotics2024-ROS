#include <iostream>
#include <vector>
#include <string>
#include <thread>
#include <mutex>

// ImGui
#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include "implot.h"

// Video capture
#include <opencv2/opencv.hpp>

// GLFW
#include <GLFW/glfw3.h>

class CameraFeed {
private:
    cv::VideoCapture cap;
    cv::Mat frame;
    GLuint textureID;
    std::mutex mtx;
    std::thread captureThread;
    bool running;
    int width, height;
    std::string devicePath;

public:
    CameraFeed(const std::string& path, int w = 640, int h = 360) 
        : devicePath(path), width(w), height(h), running(false), textureID(0) {}

    ~CameraFeed() {
        stop();
        if (textureID) {
            glDeleteTextures(1, &textureID);
        }
    }

    bool start() {
        if (running) return true;
        
        cap.open(devicePath);
        if (!cap.isOpened()) {
            std::cerr << "Failed to open camera: " << devicePath << std::endl;
            return false;
        }
        
        cap.set(cv::CAP_PROP_FRAME_WIDTH, width);
        cap.set(cv::CAP_PROP_FRAME_HEIGHT, height);
        
        // Create OpenGL texture
        glGenTextures(1, &textureID);
        glBindTexture(GL_TEXTURE_2D, textureID);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        
        running = true;
        captureThread = std::thread(&CameraFeed::captureLoop, this);
        return true;
    }

    void stop() {
        running = false;
        if (captureThread.joinable()) {
            captureThread.join();
        }
        cap.release();
    }

    void captureLoop() {
        while (running) {
            cv::Mat tempFrame;
            if (!cap.read(tempFrame)) {
                std::cerr << "Failed to read frame from: " << devicePath << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                continue;
            }
            
            // Resize if needed
            if (tempFrame.cols != width || tempFrame.rows != height) {
                cv::resize(tempFrame, tempFrame, cv::Size(width, height));
            }
            
            // Convert BGR to RGB
            cv::cvtColor(tempFrame, tempFrame, cv::COLOR_BGR2RGB);
            
            // Update texture
            {
                std::lock_guard<std::mutex> lock(mtx);
                tempFrame.copyTo(frame);
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(10)); // ~100 fps max
        }
    }

    void updateTexture() {
        std::lock_guard<std::mutex> lock(mtx);
        if (!frame.empty()) {
            glBindTexture(GL_TEXTURE_2D, textureID);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, frame.cols, frame.rows, 0, 
                         GL_RGB, GL_UNSIGNED_BYTE, frame.data);
        }
    }

    GLuint getTextureID() const {
        return textureID;
    }

    bool isRunning() const {
        return running && cap.isOpened();
    }
};

// Sample metric data
struct MetricData {
    static constexpr int MAX_POINTS = 100;
    float cpu[MAX_POINTS] = {0};
    float memory[MAX_POINTS] = {0};
    float battery[MAX_POINTS] = {0};
    float temperature[MAX_POINTS] = {0};
    int head = 0;
    
    void addSample(float cpuVal, float memVal, float batVal, float tempVal) {
        cpu[head] = cpuVal;
        memory[head] = memVal;
        battery[head] = batVal;
        temperature[head] = tempVal;
        head = (head + 1) % MAX_POINTS;
    }

    // Simulate some data for testing
    void simulateData() {
        static float cpuBase = 30.0f;
        static float memBase = 40.0f;
        static float batBase = 80.0f;
        static float tempBase = 35.0f;
        
        cpuBase += (rand() % 100 - 50) * 0.1f;
        cpuBase = std::max(5.0f, std::min(95.0f, cpuBase));
        
        memBase += (rand() % 100 - 50) * 0.05f;
        memBase = std::max(20.0f, std::min(90.0f, memBase));
        
        batBase -= (rand() % 10) * 0.01f;
        batBase = std::max(0.0f, std::min(100.0f, batBase));
        
        tempBase += (rand() % 100 - 50) * 0.05f;
        tempBase = std::max(25.0f, std::min(85.0f, tempBase));
        
        addSample(cpuBase, memBase, batBase, tempBase);
    }
};

// Main application class
class RobotDashboard {
private:
    GLFWwindow* window;
    std::vector<CameraFeed> cameras;
    MetricData metrics;
    bool running;

public:
    RobotDashboard() : window(nullptr), running(false) {}
    
    ~RobotDashboard() {
        cleanup();
    }
    
    bool init() {
        // Initialize GLFW
        if (!glfwInit()) {
            std::cerr << "Failed to initialize GLFW" << std::endl;
            return false;
        }
        
        // Create window
        window = glfwCreateWindow(1920, 1080, "Robot Dashboard", NULL, NULL);
        if (!window) {
            std::cerr << "Failed to create GLFW window" << std::endl;
            glfwTerminate();
            return false;
        }
        
        glfwMakeContextCurrent(window);
        glfwSwapInterval(1); // Enable vsync
        
        // Initialize ImGui
        IMGUI_CHECKVERSION();
        ImGui::CreateContext();
        ImPlot::CreateContext();
        ImGuiIO& io = ImGui::GetIO();
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
        
        ImGui_ImplGlfw_InitForOpenGL(window, true);
        ImGui_ImplOpenGL3_Init("#version 130");
        
        // Initialize cameras
        cameras.emplace_back("/dev/video0");
        cameras.emplace_back("/dev/video1");
        cameras.emplace_back("/dev/video2");
        cameras.emplace_back("/dev/video3");
        
        for (auto& cam : cameras) {
            if (!cam.start()) {
                std::cerr << "Warning: Failed to start some cameras" << std::endl;
            }
        }
        
        running = true;
        return true;
    }
    
    void run() {
        ImVec4 clear_color = ImVec4(0.05f, 0.05f, 0.05f, 1.00f);
        
        while (!glfwWindowShouldClose(window) && running) {
            glfwPollEvents();
            
            // Update camera textures
            for (auto& cam : cameras) {
                cam.updateTexture();
            }
            
            // Simulate real-time metrics data
            metrics.simulateData();
            
            // Start ImGui frame
            ImGui_ImplOpenGL3_NewFrame();
            ImGui_ImplGlfw_NewFrame();
            ImGui::NewFrame();
            
            // Create dashboard layout
            createDashboard();
            
            // Rendering
            ImGui::Render();
            int display_w, display_h;
            glfwGetFramebufferSize(window, &display_w, &display_h);
            glViewport(0, 0, display_w, display_h);
            glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
            glClear(GL_COLOR_BUFFER_BIT);
            ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
            
            glfwSwapBuffers(window);
        }
    }
    
    void createDashboard() {
        // Full window size
        ImGui::SetNextWindowPos(ImVec2(0, 0));
        ImGui::SetNextWindowSize(ImGui::GetIO().DisplaySize);
        
        ImGui::Begin("Dashboard", nullptr, 
            ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | 
            ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | 
            ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoBringToFrontOnFocus);
        
        // Split dashboard into left (cameras) and right (metrics) sections
        float metricsWidth = ImGui::GetContentRegionAvail().x * 0.35f;
        float camerasWidth = ImGui::GetContentRegionAvail().x - metricsWidth;
        
        ImGui::BeginChild("CamerasSection", ImVec2(camerasWidth, 0), true);
        displayCameras();
        ImGui::EndChild();
        
        ImGui::SameLine();
        
        ImGui::BeginChild("MetricsSection", ImVec2(0, 0), true);
        displayMetrics();
        ImGui::EndChild();
        
        ImGui::End();
    }
    
    void displayCameras() {
        ImGui::Text("Robot Camera Feeds");
        ImGui::Separator();
        
        // Calculate sizes for 2x2 grid
        float width = ImGui::GetContentRegionAvail().x * 0.5f - 5.0f;
        float height = ImGui::GetContentRegionAvail().y * 0.5f - 5.0f;
        
        for (size_t i = 0; i < cameras.size() && i < 4; ++i) {
            if (i % 2 != 0 && i > 0) {
                ImGui::SameLine();
            }
            
            ImGui::BeginGroup();
            ImGui::Text("Camera %zu", i);
            
            ImVec2 pos = ImGui::GetCursorScreenPos();
            if (cameras[i].isRunning()) {
                ImGui::Image((void*)(intptr_t)cameras[i].getTextureID(), ImVec2(width, height));
            } else {
                ImGui::GetWindowDrawList()->AddRectFilled(
                    pos, ImVec2(pos.x + width, pos.y + height), 
                    IM_COL32(50, 50, 50, 255));
                
                ImGui::SetCursorScreenPos(ImVec2(pos.x + width/2 - 50, pos.y + height/2 - 10));
                ImGui::Text("No Signal");
            }
            ImGui::EndGroup();
            
            if (i % 2 == 1 || i == cameras.size() - 1) {
                ImGui::Separator();
            }
        }
    }
    
    void displayMetrics() {
        ImGui::Text("Robot Metrics");
        ImGui::Separator();
        
        // Get system metrics
        static float time = 0.0f;
        time += ImGui::GetIO().DeltaTime;
        
        // CPU Usage
        if (ImPlot::BeginPlot("CPU Usage", ImVec2(-1, 150))) {
            ImPlot::SetupAxes("Time", "Usage %", 
                ImPlotAxisFlags_AutoFit | ImPlotAxisFlags_NoTickLabels, 
                ImPlotAxisFlags_AutoFit);
            ImPlot::SetupAxisLimits(ImAxis_X1, 0, MetricData::MAX_POINTS - 1, ImGuiCond_Always);
            ImPlot::SetupAxisLimits(ImAxis_Y1, 0, 100);
            
            ImPlot::PlotLine("CPU", metrics.cpu, MetricData::MAX_POINTS, 1.0, 0.0, 0, 
                sizeof(float), ImPlotLineFlags_None);
            ImPlot::EndPlot();
        }
        
        // Memory Usage
        if (ImPlot::BeginPlot("Memory Usage", ImVec2(-1, 150))) {
            ImPlot::SetupAxes("Time", "Usage %", 
                ImPlotAxisFlags_AutoFit | ImPlotAxisFlags_NoTickLabels, 
                ImPlotAxisFlags_AutoFit);
            ImPlot::SetupAxisLimits(ImAxis_X1, 0, MetricData::MAX_POINTS - 1, ImGuiCond_Always);
            ImPlot::SetupAxisLimits(ImAxis_Y1, 0, 100);
            
            ImPlot::PlotLine("Memory", metrics.memory, MetricData::MAX_POINTS, 1.0, 0.0, 0, 
                sizeof(float), ImPlotLineFlags_None);
            ImPlot::EndPlot();
        }
        
        // Battery Level
        if (ImPlot::BeginPlot("Battery Level", ImVec2(-1, 150))) {
            ImPlot::SetupAxes("Time", "%", 
                ImPlotAxisFlags_AutoFit | ImPlotAxisFlags_NoTickLabels, 
                ImPlotAxisFlags_AutoFit);
            ImPlot::SetupAxisLimits(ImAxis_X1, 0, MetricData::MAX_POINTS - 1, ImGuiCond_Always);
            ImPlot::SetupAxisLimits(ImAxis_Y1, 0, 100);
            
            ImPlot::PlotLine("Battery", metrics.battery, MetricData::MAX_POINTS, 1.0, 0.0, 0, 
                sizeof(float), ImPlotLineFlags_None);
            ImPlot::EndPlot();
        }
        
        // Temperature
        if (ImPlot::BeginPlot("Temperature", ImVec2(-1, 150))) {
            ImPlot::SetupAxes("Time", "°C", 
                ImPlotAxisFlags_AutoFit | ImPlotAxisFlags_NoTickLabels, 
                ImPlotAxisFlags_AutoFit);
            ImPlot::SetupAxisLimits(ImAxis_X1, 0, MetricData::MAX_POINTS - 1, ImGuiCond_Always);
            ImPlot::SetupAxisLimits(ImAxis_Y1, 0, 100);
            
            ImPlot::PlotLine("Temperature", metrics.temperature, MetricData::MAX_POINTS, 1.0, 0.0, 0, 
                sizeof(float), ImPlotLineFlags_None);
            ImPlot::EndPlot();
        }
        
        // Status indicators
        ImGui::Separator();
        ImGui::Text("System Status");
        
        ImGui::Columns(2);
        
        ImGui::Text("Motor Status:");
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Running");
        ImGui::NextColumn();
        
        ImGui::Text("Connection:");
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Connected");
        ImGui::NextColumn();
        
        ImGui::Text("Navigation:");
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Standby");
        ImGui::NextColumn();
        
        ImGui::Text("Alerts:");
        ImGui::NextColumn();
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "None");
        ImGui::NextColumn();
        
        ImGui::Columns(1);
    }
    
    void cleanup() {
        // Stop cameras
        for (auto& cam : cameras) {
            cam.stop();
        }
        
        // Cleanup ImGui
        ImGui_ImplOpenGL3_Shutdown();
        ImGui_ImplGlfw_Shutdown();
        ImPlot::DestroyContext();
        ImGui::DestroyContext();
        
        // Cleanup GLFW
        if (window) {
            glfwDestroyWindow(window);
        }
        glfwTerminate();
    }
};

int main() {
    RobotDashboard dashboard;
    
    if (!dashboard.init()) {
        std::cerr << "Failed to initialize dashboard" << std::endl;
        return 1;
    }
    
    dashboard.run();
    return 0;
}